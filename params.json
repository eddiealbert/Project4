{
  "name": "Multi-Level Indexing vs. Flexible # of Extents",
  "tagline": "A look at sequential and random access speed, along with fragmentation in both file system implementations",
  "body": "### What metrics have to be considered when creating a file system?\r\nFragmentation is one such metric to take into consideration when designing a file system. We measure this by looking at how much free space can't be used by our current implementation. The performance of random and sequential access of data blocks are also good metrics to optimize for when designing your system. \r\n\r\n### How can we implement a file system that performs optimally when taking these three metrics into consideration?\r\nI looked at two possible file system implementations as solutions.\r\n+ **Multi-Level Indexing**\r\n    - This implementation dynamically allocates a hierarchy of pointers as needed.\r\n    - Pointers are only created when needed so that meta data is kept to a minimum.\r\n    - There are additional pointers to indirect blocks of pointers for larger files.\r\n\r\n+ **Flexible # of Extents**\r\n    - This implementation dynamically uses extents (contiguous regions/blocks) for each file.\r\n    - The extents are organized in a multi-level tree structure.\r\n    - Leaf nodes hold the meta data: starting block and contiguous size (how many blocks it takes up)\r\n\r\n### Challenges/Solutions\r\n\r\nThe two file system implementations I chose to study are rather complex, so implementing them was not an easy task. As a result, I tried to keep some parts of my implementation simple. For instance, instead of working with actual files, I used Strings to represent files. If I needed to split up a \"file\" into a set of extents, I just split the string into characters for each extent. For the Multi-Level Index implementation, I had to figure out how I would determine how many blocks could be filled before I had to incorporate an indirect block of pointers. I settled for a system where if a file was greater than 3 blocks (or characters) in size, the fourth pointer would be aimed at an indirect block. I needed to put these blocks somewhere, so I created a Memory class that holds a 64 Block array. This class stores the actual data.  \r\n\r\nIn order to compare both implementations, I decided to create a Test class where I would do all of my comparisons. I also use this class to dynamically generate strings of various lengths so that I can test my results on a variety of data sets. That class has methods for generating files and for timing each file structure's access speeds. I can control the level of randomness in the generated test cases with a Boolean I called totallyRandom. If set to true, the size of files can vary wildly to the point where a single file can take up about half of the blocks on disk. If set to false, the files are kept rather small and only take up a maximum of 9 blocks.\r\n\r\n### How have I compared each implementation?\r\nI used my Memory's freeSpace() method to see if there are any unused blocks of memory left on disk when testing for fragmentation. At the moment I am debugging the methods that test sequential and random access for both implementations. The problem appears to lie in my implementation of the inode block class.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}